import java.io.*;
import java.util.TreeMap;

public class Analyze {

    /**
     * Collects information about the distribution of RPKM values.
     */
    private static void readCountDistribution(String fileName, boolean halfs) throws IOException {
        File readMapInfo = new File("analysis/" + fileName);
        BufferedReader br = new BufferedReader(new FileReader(readMapInfo));

        TreeMap<Double, Integer> allReadCounts = new TreeMap<>();
        String line;
        String[] splitLine;
        File outputFile;
        if(!halfs) {
            outputFile = new File("analysis/out_" + fileName);
        } else {
            outputFile = new File("analysis/out-h_" + fileName);
        }
        outputFile.createNewFile();
        FileOutputStream fileOutStream = new FileOutputStream(outputFile);
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fileOutStream));

        double libSize = 1;

        // collect read counts
        while((line = br.readLine()) != null) {
            splitLine = line.split("\t");
            if(line.startsWith("#")) {
                libSize = Double.parseDouble(splitLine[1]);
            } else {
                float readCount = Float.parseFloat(splitLine[1]);
                float mergeLength = Float.parseFloat(splitLine[2]);
                // normalize for reads per kilobase
                double nReadCount = (double)(readCount / mergeLength * 1000);     // RPK
                // normalize for million mapped reads
                nReadCount = nReadCount/libSize * 1000000;         // RPKM
                double normReadCount;
                if(!halfs) {
                    normReadCount = (long) nReadCount;
                } else {
                    normReadCount = Math.round(nReadCount * 2)/2.0;
                }
                if(allReadCounts.containsKey(normReadCount)) {
                    allReadCounts.replace(normReadCount, allReadCounts.get(normReadCount) + 1);
                } else {
                    allReadCounts.put(normReadCount, 1);
                }
            }
        }

        // write distribution in output file
        double old = allReadCounts.firstKey();
        for(Double l : allReadCounts.keySet()) {
            if(!halfs) {
                fillIn(old, l, bw);
            } else {
                fillInHalfs(old, l, bw);
            }
            bw.write(l + "\t" + allReadCounts.get(l));
            bw.newLine();
            old = l;
        }
        bw.close();

        /*
        thoughts about RPKM distribution (looks like e^(-x)):
        more small values because more genes with lower readcounts?
         */
    }

    /**
     * Fills in 0 values in files for plotting.
     * @param old
     * @param x
     * @param bw
     * @throws IOException
     */
    private static void fillIn(double old, double x, BufferedWriter bw) throws IOException {
        if(old + 1 != x) {
            for(double i = old + 1; i < x; i++) {
                bw.write(i + "\t" + 0);
                bw.newLine();
            }
        }
    }

    /**
     * Fills in 0 values in files for plotting.
     * @param old
     * @param x
     * @param bw
     * @throws IOException
     */
    private static void fillInHalfs(double old, double x, BufferedWriter bw) throws IOException {
        if(old + 0.5 != x) {
            for(double i = old + 0.5; i < x; i += 0.5) {
                bw.write(i + "\t" + 0);
                bw.newLine();
            }
        }
    }

    /**
     * Analyzes the out files generated by readCountDistribution() into relative numbers.
     * @param fileName
     * @throws IOException
     */
    private static void readCountDistRel(String fileName) throws IOException {
        File readMapInfo = new File("analysis/" + fileName);
        BufferedReader br = new BufferedReader(new FileReader(readMapInfo));

        long sum = 0;
        String line;
        String[] splitLine;
        File outputFile;
        outputFile = new File("analysis/r_" + fileName);
        outputFile.createNewFile();
        FileOutputStream fileOutStream = new FileOutputStream(outputFile);
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fileOutStream));

        // collect total sum
        while((line = br.readLine()) != null) {
            splitLine = line.split("\t");
            sum += Long.parseLong(splitLine[1]);
        }
        br = new BufferedReader(new FileReader(readMapInfo));

        // write percentages
        while((line = br.readLine()) != null) {
            splitLine = line.split("\t");
            float percentage = (float)(Double.parseDouble(splitLine[1])/(float)sum);
            bw.write(splitLine[0] + "\t" + percentage);
            bw.newLine();
        }

        bw.close();
    }

    public static void main(String[] args) throws IOException {
        // readCountDistribution("info_nookaew_cm.tsv", true);
        readCountDistRel("out-h_info_nookaew_cm.tsv");
    }
}
